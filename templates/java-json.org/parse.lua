[@lua
   include 'java-json.org/itemstrategy.lua'
   include 'java-json.org/listitemstrategy.lua'
   include 'java-json.org/types.lua'

   -- TODO: 1) use optJSONArray/opt... for optional fields
   --       2) make unmarshalling/marshaling handle fields which can be lists
   --          of one, in which case they are not in brackets

   -- helper functions
   local function isSimpleType(typedef) 
	  return (next(typedef.fields) == nil)
   end

   local function isListType(typename)
	  return (typename:match("^(list)%(.+%)") ~= nil)
   end

   local function isFieldRequired(typedef)
	  return (typedef.use and "required" == typedef.use)
   end

   local function getListType(typeName)
	  return typeName:match("list%((.+)%)")
   end
   
   local function fieldIterator(tbl)
	  local function itr(tbl, i)
		 local jsonTag, typeTbl = next(tbl, i)
		 return jsonTag, unpack(jsonTag and {next(typeTbl)} or {})
	  end
	  return itr, tbl, nil
   end

   local function makeJavaSafeName(fieldName)
	  if '$' == fieldName then
		 return 'value'
	  else
		 return fieldName:gsub('[%$,/,-,%%,#,@,!,%^,&,*,%(,%),  ,]', '_')
	  end
   end

   local function outputGeterJavadoc(typename, memberName)
	  local str = stringBuffer:new()
	  str:append('\t/**\n')
	  str:append(
		 ('\t * Gets the value of the %s property.\n'):format(memberName)
	  )
	  str:append('\t *\n')
	  str:append('\t * @return\n')
	  str:append('\t *     possible object is\n')
	  str:append(('\t *     {@link %s}\n'):format(typename))
	  str:append('\t */\n')
	  return str:str()
   end

   local function outputSeterJavadoc(typename, memberName)
	  local str = stringBuffer:new()
	  str:append('\t/**\n')
	  str:append(
		 ('\t * Sets the value of the %sVal property.\n'):format(memberName)
	  )
	  str:append('\t *\n')
	  str:append(('\t * @param %sVal\n'):format(memberName))
	  str:append('\t *     allowed object is\n')
	  str:append(('\t *     {@link %s}\n'):format(typename))
	  str:append('\t */\n')
	  return str:str()
   end


   -- json output function
   local function objectOutput(typename, typedef)
	  local str = stringBuffer:new()
	  -- generate file and import headers
	  str:append(('/* FILE: %s.java */\n'):format(typename))
	  str:append('/* This file was generated by xsdb */\n')
	  str:append(('package %s;\n'):format(javaPKGName))
	  str:append('import java.util.Vector;\n')
	  str:append('import org.json.JSONObject;\n')
	  str:append('import org.json.JSONArray;\n')
	  str:append('import org.json.JSONException;\n')
	  str:append(('import %s.Marshallable;\n'):format(javaPKGName))
	  str:append(('import %s.JSONObjectAdapter;\n'):format(javaPKGName))
	  str:append(('import %s.JSONArrayAdapter;\n\n'):format(javaPKGName))
	  -- generate class definition	  
	  str:append(
		 ('public class %s implements Marshallable {\n'):format(typename)
	  )	  
	  -- generate private members
	  for JSONFieldName, fieldTypename in fieldIterator(typedef.fields) do
		 local memberName  = makeJavaSafeName(JSONFieldName)
		 if isListType(fieldTypename) then
			local lstTypename = getListType(fieldTypename)
			str:append(
			   ListItemStrategy.declaration(
				  types[lstTypename], memberName
			   )
			)
		 else
			str:append(
			   ItemStrategy.declaration(
				  types[fieldTypename], memberName
			   )
			)
		 end
	  end
	  -- generate default constructor
	  str:append(('\n\tpublic %s() {\n\t}\n\n'):format(typename))
	  -- generate default unmarshall constructor
	  local fmt = '\tpublic %s(JSONObject jObj) throws JSONException {\n'
	  str:append(fmt:format(typename))
	  str:append('\t\tthis(new JSONObjectAdapter(jObj));\n')
	  str:append('\t}\n\n')
	  -- generate unmarshall constructor
	  local fmt = '\tpublic %s(JSONObjectAdapter jObj) throws JSONException {\n'
	  str:append(fmt:format(typename))
	  for fieldName, fieldType, fieldTypedef in fieldIterator(typedef.fields) do
		 local memberName  = makeJavaSafeName(fieldName)
		 if not isFieldRequired(fieldTypedef) then
			str:append(('\t\tif (!jObj.has("%s"))\n'):format(fieldName))
			str:append(('\t\t\t_%s = null;\n'):format(memberName))
			str:append('\t\telse\n')
			if not isListType(fieldType) then str:append('\t') end
		 end
		 if isListType(fieldType) then
			local lstType = getListType(fieldType)
			str:append(
			   ListItemStrategy.unmarshall(
				  types[lstType], memberName, fieldName
			   )
			)
		 else
			str:append(
			   ItemStrategy.unmarshall(
				  types[fieldType], memberName, fieldName
			   )
			)
		 end
	  end
	  str:append('\t}\n\n')
	  -- generate 'set'ers
	  for fieldName, fieldType, fieldTypedef in fieldIterator(typedef.fields) do
		 local memberName  = makeJavaSafeName(fieldName)
		 if isListType(fieldType) then
			local lstType  = getListType(fieldType)
			local javaType = types[lstType]
			str:append(
			   outputSeterJavadoc(
				  ('Vector<%s>'):format(javaType.typename), memberName
			   )
			)
			str:append(ListItemStrategy.seter(javaType, memberName))
		 else
			local javaType = types[fieldType]
			str:append(outputSeterJavadoc(javaType.typename, memberName))
			str:append(ItemStrategy.seter(javaType, memberName))
		 end
	  end
	  -- generate 'get'ers
	  for fieldName, fieldType, fieldTypedef in fieldIterator(typedef.fields) do
		 local memberName  = makeJavaSafeName(fieldName)
		 if isListType(fieldType) then
			local lstType  = getListType(fieldType)
			local javaType = types[lstType]
			str:append(
			   outputGeterJavadoc(
				  ('Vector<%s>'):format(javaType.typename), memberName
			   )
			)
			str:append(ListItemStrategy.geter(javaType, memberName))
		 else
			local javaType = types[fieldType]
			str:append(outputGeterJavadoc(javaType.typename, memberName))
			str:append(ItemStrategy.geter(javaType, memberName))
		 end
	  end
	  -- generate marshall funciton
	  str:append('\tpublic JSONObject marshall() throws JSONException {\n')
	  str:append(
		 '\t\tJSONObjectAdapter retObj = new JSONObjectAdapter(new JSONObject());\n'
	  )
	  for fieldName, fieldType, fieldTypedef in fieldIterator(typedef.fields) do
		 local memberName  = makeJavaSafeName(fieldName)
		 if not isFieldRequired(fieldTypedef) then
			str:append(
			   ('\t\tif (null != _%s && 0 < _%s.size())\n'):format(
				  memberName, memberName
			   )
			)
			if not isListType(fieldType) then str:append('\t') end
		 end
		 if isListType(fieldType) then
			local lstType = getListType(fieldType)
			str:append(
			   ListItemStrategy.marshall(
				  types[lstType], memberName, fieldName
			   )
			)
		 else
			str:append(
			   ItemStrategy.marshall(
				  types[lstType], memberName, fieldName
			   )
			)
		 end
	  end
	  str:append('\t\treturn retObj.getJSONObject();\n')
	  str:append('\t}\n')
	  -- add end brace
	  str:append('}\n')
	  return str:str()
   end

   function printTbl(tbl, depth)
	  depth = depth or 0
	  for k,v in pairs(tbl) do
		 if "table" == type(v) then
			if nil == next(v) then 
			   dbgPrint(string.rep("  ", depth)..k.." = {}")
			else
			   dbgPrint(string.rep("  ", depth)..k.." = {")
			   printTbl(v, depth + 1)
			   dbgPrint(string.rep("  ", depth).."}")
			end
		 else
			print(string.rep("  ", depth)..k.." = "..v)
		 end
	  end
   end


   -- json iteration function
   function outputJSON(JSONSchema)
	  local visitType = {}
	  local outputStr = stringBuffer:new()
	  local function _traverse(JSONType)
		 dbgPrint('_traverse: '..tostring(JSONType))
		 for tagname, typetable in pairs(JSONType.fields) do
			local typename, typedef = next(typetable)
			-- if type is not simple and not already referenced
			if not (visitType[typename] or isSimpleType(typedef)) then 
			   visitType[typename] = true
			   outputStr:append(objectOutput(typename, typedef))
			   _traverse(typedef)
			end
		 end
	  end
	  _traverse({fields = JSONSchema})
	  return outputStr:str()
   end
]