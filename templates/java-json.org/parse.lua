[@lua
include 'java-json.org/itemstrategy.lua'
include 'java-json.org/listitemstrategy.lua'
include 'java-json.org/types.lua'

local function isEmpty(list)
   return (next(list) == nil)
end

local function isMoreThanOne(list)
   return (next(list, next(list)) ~= nil)
end

local function isSimpleType(type) 
   return ((next(type.attributes) or next(type.content)) == nil)
end

local function isRootElement(type)
  for _, v in pairs(schema) do
	if v == type then return True end
  end  
  return False;
end

local function isCollapsibleType(type)
   return (isRootElement(type) and 
	   isEmpty(type.attributes) and 
	   not isMoreThanOne(type.content))
end

local function collapseType(type)
   return next(type.content)
end

local function isListType(typeName)
   return (typeName:match("^(list)%(.+%)") ~= nil)
end

local function listType(typeName)
   return typeName:match("list%((.+)%)")
end

local function isBaseType(typeName)
  typeName = isListType(typeName) and listType(typeName) or typeName
  return (rawget(types, typeName) ~= nil)
end

local function isAttributeRequired(type)
--   dbgPrint('isAttributeRequired(',type,')')
   return (nil ~= type.use and "required" == type.use)
end

local function isAttributeFixed(type)
--   dbgPrint('isAttributeFixed(',type,')')
   return (nil ~= type.fixed)
end

local function hasAttributeDefault(type)
--   dbgPrint('hasAttributeDefault(',type,')')
   return (nil ~= type.default)
end

local function defaultAttributeVal(type)
--   dbgPrint('defaultAttributeVal(',type,')')
   if isAttributeFixed(type) then 
      return type.fixed 
   elseif hasAttributeDefault(type) then
      return type.default
   else
      return nil
   end
end

local function outputSeterJavadoc(str, typename, var)
   -- pattern for 'set'ers properties
   local fmt = {
	  '\t/**\n',
	  '\t * Sets the value of the %sVal property.\n',
	  '\t *\n',
	  '\t * @param %sVal\n',
	  '\t *     allowed object is\n',
	  '\t *     {@link %s}\n',
	  '\t */\n',
   }
   str:append(fmt[1])
   str:append(fmt[2]:format(var))
   str:append(fmt[3])
   str:append(fmt[4]:format(var))
   str:append(fmt[5])
   str:append(fmt[6]:format(typename))
   str:append(fmt[7])
end

local function wrapVector(typename)
   return 'Vector<'..typename..'>'
end

local function outputGeterJavadoc(str, typename, var)
   -- pattern for 'set'ers properties
   local fmt = {
	  '\t/**\n',
	  '\t * Gets the value of the %s property.\n',
	  '\t *\n',
	  '\t * @return\n',
	  '\t *     possible object is\n',
	  '\t *     {@link %s}\n',
	  '\t */\n',
   }
   str:append(fmt[1])
   str:append(fmt[2]:format(var))
   str:append(fmt[3])
   str:append(fmt[4])
   str:append(fmt[5])
   str:append(fmt[6]:format(typename))
   str:append(fmt[7])
end


function elementParser(name, XSDElement) 
   local str = stringBuffer:new()
   -- if type is collapsible, don't output it or if it is a base type or the schema root
   if isBaseType(name) or isCollapsibleType(XSDElement) or name == '' then
	 return ''
   end
   -- generate class definition
   local fmt = {
      '/* FILE: %s.java */\n',
      '/* This file was generated by xsdb */\n',
      'package %s;\n',
      'import java.util.Vector;\n',
      'import org.json.JSONObject;\n',
      'import org.json.JSONArray;\n',
      'import org.json.JSONException;\n',
	  'import %s.Marshallable;\n',
	  'import %s.JSONObjectAdapter;\n',
	  'import %s.JSONArrayAdapter;\n\n'
   }
   str:append(fmt[1]:format(name))
   str:append(fmt[2])
   str:append(fmt[3]:format(javaPKGName))
   str:append(fmt[4])
   str:append(fmt[5])
   str:append(fmt[6])
   str:append(fmt[7])
   str:append(fmt[8]:format(javaPKGName))
   str:append(fmt[9]:format(javaPKGName))
   str:append(fmt[10]:format(javaPKGName))
   local fmt = 'public class %s implements Marshallable {\n'
   str:append(fmt:format(name))
   -- generate private members from attributes
   for name, attribute in pairs(XSDElement.attributes) do
      local attribTypeName, attribTypeDef = next(attribute, nil)
      str:append(
	 ItemStrategy.declaration(
		    types[attribTypeName], 
		    name,
		    defaultAttributeVal(attribTypeDef)
		 )
      )
   end
   -- generate private memebers from content types
   for name, typedef in pairs(XSDElement.content) do
      if isSimpleType(typedef) then
		 if isListType(name) then
			local lstTypeName = listType(name)
			str:append(ListItemStrategy.declaration(types[lstTypeName], 'value'))
		 else
			str:append(ItemStrategy.declaration(types[name], 'value'))
		 end
      elseif isCollapsibleType(typedef) then
		 local typeName, collapsedType = collapseType(typedef)
		 str:append(ListItemStrategy.declaration(types[typeName], name))
      else
		 str:append(ListItemStrategy.declaration(types[name], name))
      end
   end
   -- generate default constructor
   local fmt = '\n\tpublic %s() {\n\t}\n\n'
   str:append(fmt:format(name))
   -- generate default unmarshall constructor
   local fmt = {
      '\tpublic %s(JSONObject jObj) throws JSONException {\n',
	  '\t\tthis(new JSONObjectAdapter(jObj));\n',
      '\t}\n\n'
   }
   str:append(fmt[1]:format(name))
   str:append(fmt[2])
   str:append(fmt[3])
   -- generate unmarshall constructor
   local fmt = {
      '\tpublic %s(JSONObjectAdapter jObj) throws JSONException {\n',
      '\t}\n\n'
   }
   str:append(fmt[1]:format(name))
   -- unmarshall attributes in constructor
   for name, attribute in pairs(XSDElement.attributes) do
      local attribType, attribTypedef = next(attribute)
      if isAttributeRequired(attribTypedef) then	 
	 str:append(ItemStrategy.unmarshall(types[attribType], name, '@'..name))
      else
	 local fmt = {
	    '\t\tif (jObj.has("%s"))\n', 
	    '\t%s',
	    '\t\telse\n',
	    '\t\t\t_%s = null;\n'
	 }
	 str:append(fmt[1]:format('@'..name))
	 str:append(fmt[2]:format(ItemStrategy.unmarshall(types[attribType], name, '@'..name)))
	 str:append(fmt[3])
	 str:append(fmt[4]:format(name))
      end
   end
   -- unmarshall content in constructor
   for ctntType, ctntTypeDef in pairs(XSDElement.content) do
      if isSimpleType(ctntTypeDef) then
		if isListType(ctntType) then
		  local lstTypeName = listType(ctntType)
		  str:append(ListItemStrategy.unmarshall(types[lstTypeName],'value', '$'))
		else
		  str:append(ItemStrategy.unmarshall(types[ctntType], 'value', '$'))
		end
	  elseif isCollapsibleType(ctntTypeDef) then
		local colTypeName = collapseType(ctntTypeDef)
		str:append(ListItemStrategy.unmarshall(types[colTypeName], ctntType, ctntType))
	  else
		str:append(ListItemStrategy.unmarshall(types[ctntType], ctntType, ctntType))
      end
   end
   str:append('\t}\n\n')
   -- generate 'set'ers from attributes
   for name, attribute in pairs(XSDElement.attributes) do
      local attribType, attribTypeDef = next(attribute, nil)
      if not isAttributeFixed(attribTypeDef) then
		 local javaType = types[attribType]
		 -- generate javadoc comments
		 outputSeterJavadoc(str, javaType.typename, name)
		 -- generate method code
		 str:append(ItemStrategy.seter(javaType, name))
      end
   end
   -- generate 'set'ers from content
   for name, typedef in pairs(XSDElement.content) do
	  if isSimpleType(typedef) then
		 if isListType(name) then
			local lstTypeName = listType(name)
			local javaType = types[lstTypeName]
			-- generate javadoc comments
			outputSeterJavadoc(str, wrapVector(javaType.typename), 'value')
			-- generate method code
			str:append(ListItemStrategy.seter(javaType, 'value'))
		 else
			local javaType = types[name]
			-- generate javadoc comments
			outputSeterJavadoc(str, javaType.typename, 'value')
			-- generate method code
			str:append(ItemStrategy.seter(javaType, 'value'))
		 end
	  elseif isCollapsibleType(typedef) then
		 local colTypeName, colType = collapseType(typedef)
		 local javaType = types[colTypeName]
		 -- generate javadoc comments
		 outputSeterJavadoc(str, wrapVector(javaType.typename), name)
		 -- generate method code
		 str:append(ListItemStrategy.seter(javaType, name))
	  else
		 local javaType = types[name]
		 -- generate javadoc comments
		 outputSeterJavadoc(str, wrapVector(javaType.typename), name)
		 -- generate method code
		 str:append(ListItemStrategy.seter(javaType, name))
	  end
   end
   -- generate 'get'ers from attributes
   for name, attribute in pairs(XSDElement.attributes) do
      attribName, attribType = next(attribute)
	  local javaType = types[attribName]
	  -- generate javadoc comments
	  outputGeterJavadoc(str, javaType.typename, name)
	  -- generate method code
      str:append(ItemStrategy.geter(javaType, name))
   end
   -- generate 'get'ers from content
   for name, typedef in pairs(XSDElement.content) do
	  if isSimpleType(typedef) then
		 if isListType(name) then
			local lstTypeName = listType(name)
			local javaType = types[lstTypeName]
			-- generate javadoc comments
			outputGeterJavadoc(str, wrapVector(javaType.typename), 'value')
			-- generate method code
			str:append(ListItemStrategy.geter(javaType, 'value'))
		 else
			local javaType = types[name]
			-- generate javadoc comments
			outputGeterJavadoc(str, javaType.typename, 'value')
			-- generate method code
			str:append(ItemStrategy.geter(javaType, 'value'))
		 end
      elseif isCollapsibleType(typedef) then
		 local colTypeName, colType = collapseType(typedef)
		 local javaType = types[colTypeName]
		 -- generate javadoc comments
		 outputGeterJavadoc(str, wrapVector(javaType.typename), name)
		 -- generate method code
		 str:append(ListItemStrategy.geter(javaType, name))
      else
		 local javaType = types[name]
		 -- generate javadoc comments
		 outputGeterJavadoc(str, wrapVector(javaType.typename), name)
		 -- generate method code
		 str:append(ListItemStrategy.geter(javaType, name))
      end
   end
   -- generate marshall funciton
   str:append('\tpublic JSONObject marshall() throws JSONException {\n')
   str:append('\t\tJSONObjectAdapter retObj = new JSONObjectAdapter(new JSONObject());\n')
   -- marshall attributes
   for name, attribute in pairs(XSDElement.attributes) do
      local attribTypeName, attribTypedef = next(attribute)
      if isAttributeRequired(attribTypedef) then	 
	 str:append(
	    ItemStrategy.marshall(types[attribTypeName], name, '@'..name)
	 )
      else
	 local fmt = {
	    '\t\tif (null != _%s)\n',
	    '\t%s'
	 }
	 str:append(fmt[1]:format(name))
	 str:append(fmt[2]:format(ItemStrategy.marshall(
				     types[attribTypeName], 
				     name, 
				     '@'..name
				  )
			    ))
      end
   end
   -- marshall content
   for ctntType, ctntTypeDef in pairs(XSDElement.content) do
	 if isSimpleType(ctntTypeDef) then
	   if isListType(ctntType) then
		 local lstTypeName = listType(ctntType)
		 str:append(ListItemStrategy.marshall(types[lstTypeName], 'value', '$'))
	   else
		 str:append(ItemStrategy.marshall(types[ctntType], 'value', '$'))
	   end
	 elseif isCollapsibleType(ctntTypeDef) then
	   local colTypeName = collapseType(ctntTypeDef)
	   str:append(ListItemStrategy.marshall(types[colTypeName], ctntType, ctntType))
	 else
	   str:append(ListItemStrategy.marshall(types[ctntType], ctntType, ctntType))
	 end
   end
   str:append('\t\treturn retObj.getJSONObject();\n')
   str:append('\t}\n')
   -- add end brace
   str:append('}\n')
   return str:str()
end
]