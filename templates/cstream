[@lua --include and transform old format
	include 'shared/trnsfrm_old'
	schema = trnsfrm_oldFmt(schema)
][@lua --include any shared 'helper' templates
	return include 'shared/schemaEx'
][@lua --include xsd to c type mapping
	return include 'c-stream/c_type_info'
][@lua --rename any non-c-safe names to c-safe names & sort dependencies so that they are matched correctly
	schema = schema.c_safeNames()
	depOrder = schema.sortDependencies()
	depOrderSansRoot = table.filter(depOrder, function(k,v) return v.name ~= schema.root and v or nil end)
][@lua -- create friendly root schema name
	schemaName = schema.types[schema.root].name:gsub("_xsd$", "")
][@lua -- find all unique types used in xsd
	uniqueXSDTypes = schema.uniqueTypes()
	-- map xsd types to unique c-types
	uniqueCTypes = {}
	table.map(uniqueXSDTypes, function(_, v)
		local ctype = c_type_info[v]
		uniqueCTypes[ctype] = ctype
		if 'c_list' == ctype.type then
			local baseType = ctype.baseType()
			uniqueCTypes[baseType] = baseType
		end
	end)
	-- seperate list types from non-list types
	uniqueLists = table.filter(uniqueCTypes, function(_,v)
		if 'c_list' == v.type then return v end
	end)
	uniqueNonLists = table.filter(uniqueCTypes, function(_,v)
		if 'c_list' ~= v.type then return v end
	end)
]/* command to split output: csplit - '/\/\* FILE: /' {2} */
/* FILE: xmlb_common.h */
/* This file was generated by xsdb */
#include <stdint.h>

typedef struct {
	uint8_t*	m_pBuf;
	uint32_t	m_size;
	uint32_t	m_used;
} xmlb_buffer;

/* FILE: xmlb_[@lua return schemaName].h */
/* This file was generated by xsdb */
#include <string.h>
#include "xmlb_common.h"

[@lua -- output all non-list type declarations
	local outbuf = stringBuffer:new()
	-- output basic type definitions
	table.map(uniqueNonLists, function(k,v)
		outbuf:append(v.c_type.definition())
		outbuf:append("\n")
	end)
	-- output list type definitions
	table.map(uniqueLists, function(k,v)
		outbuf:append(v.c_type.definition())
		outbuf:append("\n")
	end)
	-- output element definitions
	table.map(depOrderSansRoot, function(k, node)
		outbuf:append(table.concat({
			'typedef struct {\n',
			'\tuint32_t\tm_id;\n',
		}))
		table.map(node.attributes, function(name, xsdType)
			outbuf:append(table.concat({
				'\t', c_type_info[xsdType.type].c_type.statement(name),
			}))
		end)
		if next(node.content) then
			outbuf:append(table.concat({
				'\t', c_type_info[node.content.type].c_type.statement("Content"),
			}))
		end
		outbuf:append('} xmlb_'..node.name..';\n\n')
	end)
	return outbuf:str()
]
typedef struct xmlb_marshaller {
	xmlb_buffer m_remBuf;
	xmlb_buffer m_elmStk;
	xmlb_buffer m_mrshllBuf;
	void* (*realloc)(struct xmlb_marshaller* pThis, void* pMem, size_t size);
[@lua --output unmarshalling callback structs
	local outbuf = stringBuffer:new()
	local methodFmtStr = '\tvoid (*unmarshall_%s)(struct xmlb_marshaller* pThis, const xmlb_%s* pObj, uint32_t parent);\n'
	table.map(depOrderSansRoot, function(k,v) outbuf:append(methodFmtStr:format(v.name, v.name)) end)
	return outbuf:str()
]} xmlb_marshaller;

[@lua --output marshalling callback structs
	local outbuf = stringBuffer:new()
	-- function for finding leaf nodes
	local isNotLeaf = (function(k,v) return next(v.dependents) and v or nil end)
	local isLeaf    = (function(k, v) return (not next(v.dependents)) and v or nil end)
	-- output code for all non-leaf functions
	table.map(table.filter(depOrder, isNotLeaf), function(k, node)
		outbuf:append('typedef struct {\n')
		-- find all child leaf nodes and output them
		table.map(table.filter(node.dependents, isLeaf), function(_, node)
			outbuf:append(string.format(
				'\tvoid (*marshall_%s)(xmlb_marshaller* pMarshaller, const xmlb_%s* pObj);\n',
				node.name,
				node.name
			))
		end)
		-- find all child  non leaf nodes and output them
		table.map(table.filter(node.dependents, isNotLeaf), function(_, node)
			outbuf:append(string.format(
				'\tmarshall_%s (*marshall_%s)(xmlb_marshaller* pMarshaller, const xmlb_%s* pObj);\n',
				node.name,
				node.name,
				node.name
			))
		end)
		outbuf:append('} marshall_'..node.name..';\n\n')
	end)
	return outbuf:str()
][@lua
	if next(schema.types[schema.root].dependents) then
		return table.concat({
			'marshall_', schema.root,' marshallBin(xmlb_marshaller* pMarshaller);\n',
		})
	else
		return 'void marshallBin(xmlb_marshaller* pMarshaller);\n'
	end
]xmlb_buffer marshallBin_flush(xmlb_marshaller* pMarshaller, int isDocEnd);
void unmarshallBin(xmlb_marshaller* pMarshaller, const xmlb_buffer* pBuf);

/* FILE: xmlb_[@lua return schemaName].c */
/* This file was generated by xsdb */
#include <stdlib.h>
#include <alloca.h>
#include "xmlb_[@lua return schemaName].h"

#define _buffer_pushElm(PTR, BUF, VAL)	_buffer_append(PTR, BUF, &VAL, sizeof(VAL))
#define _buffer_topElmPtr(BUF)			((xmlb_elmRec*)((BUF)->m_pBuf + (BUF)->m_used - sizeof(xmlb_elmRec)))
#define _buffer_topElmID(BUF)			(_buffer_topElmPtr(BUF)->m_id)
#define _initTLV(MRSHLLR, TYPEID)		{ .m_type = TYPEID, .m_size = sizeof(xmlb_TLV), .m_parent = _buffer_topElmID(&MRSHLLR->m_elmStk) }
#define _streamBlkRead(STRM,SIZE)		STRM; STRM+=(SIZE);
#define _streamRead(STRM,TYPE)			*((TYPE*)STRM); STRM+=sizeof(TYPE)

typedef struct {
	uint32_t	m_type, m_size, m_parent;
	uint8_t		m_data[0];
} xmlb_TLV;

typedef struct {
	uint32_t	m_type, m_id;
} xmlb_elmRec;

static void _buffer_destroy(xmlb_marshaller* pMarshaller, xmlb_buffer* pBuf) {
	if (pBuf->m_pBuf)
		pMarshaller->realloc(pMarshaller, pBuf->m_pBuf, 0);
	memset(pBuf, 0, sizeof(xmlb_buffer));
}

static void _buffer_append(xmlb_marshaller* pMarshaller, xmlb_buffer* pBuf, const void* pBlk, uint32_t size) {
	const uint32_t totalSz = size + pBuf->m_used;
	if (totalSz >= pBuf->m_size) {
		pBuf->m_pBuf = pMarshaller->realloc(pMarshaller, pBuf->m_pBuf, (pBuf->m_size) ? pBuf->m_size <<= 1 : (pBuf->m_size = 256));
	}
	memcpy(pBuf->m_pBuf + pBuf->m_used, pBlk, size);
	pBuf->m_used += size;
}

static int _marshallBin_adjustElmStk(xmlb_marshaller* pMarshaller, uint32_t validType) {
	xmlb_buffer* pElmStk = &pMarshaller->m_elmStk;
	const xmlb_elmRec* pElm = _buffer_topElmPtr(pElmStk);
	for (; (pElm >= (xmlb_elmRec*)pElmStk->m_pBuf) && (pElm->m_type != validType); --pElm) {}
	if (pElm < (xmlb_elmRec*)pElmStk->m_pBuf) return 0;
	pElmStk->m_used = (((uint8_t*)pElm) - pElmStk->m_pBuf) + sizeof(xmlb_elmRec);
	return 1;
}

[@lua -- output basic type marshalling, unmarshalling & deletion functions
	local outbuf = stringBuffer:new()
	table.map(uniqueNonLists, function(_, xsdtype)
		outbuf:append(xsdtype.binding.marshall.definition())
		outbuf:append("\n")
		outbuf:append(xsdtype.binding.unmarshall.definition())
		outbuf:append("\n")
		outbuf:append(xsdtype.delete.definition())
		outbuf:append("\n")
	end)
	return outbuf:str()
]
[@lua -- output list marshalling, unmarshalling functions
	local outbuf = stringBuffer:new()
	table.map(uniqueLists, function(_, xsdtype)
		outbuf:append(xsdtype.binding.marshall.definition())
		outbuf:append("\n")
		outbuf:append(xsdtype.binding.unmarshall.definition())
		outbuf:append("\n")
		outbuf:append(xsdtype.delete.definition())
		outbuf:append("\n")
	end)
	return outbuf:str()
]
[@lua --output marshalling functions
	local outbuf = stringBuffer:new()
	table.map(depOrderSansRoot, function(k, node)
		-- output function header
		local fncHdrFmt = 'static %s _marshallBin_%s(xmlb_marshaller* pMarshaller, const xmlb_%s* pObj) {\n'
		outbuf:append(fncHdrFmt:format(
			(not next(node.dependents)) and 'void' or 'marshall_'..node.name,
			node.name,
			node.name
		))
		-- output some variable declerations
		outbuf:append(table.concat({
			'\txmlb_buffer tmpBuf = { NULL, 0 };\n',
			'\txmlb_TLV tlv = _initTLV(pMarshaller, ',sdbm_hash(node.name),'u);\n',
			'\txmlb_buffer* pOutBuf = &pMarshaller->m_mrshllBuf;\n'
			}))
		-- output some variable declerations if type has dependents
		if next(node.dependents) then
			local depFncLst = table.filter(node.dependents, function(k,v)
				return table.concat({
					'.marshall_', k, ' = ', '_marshallBin_', k
				})
			end)
			outbuf:append(table.concat({
				'\tconst xmlb_elmRec elemRec = {',sdbm_hash(node.name),', pObj->m_id};\n',
				'\tstatic const marshall_',node.name,' retFuncs = {',table.concat(depFncLst,', '),'};\n',
			}))
		end
		-- find parent node of this node
		local function findParent(root, key)
			local _, dep = next(root.dependents, key)
			if not dep or dep == node then
				return dep == node and root or dep
			else
				return findParent(dep) or findParent(root, dep.name)
			end
		end
		local parent = findParent(schema.types[schema.root])
		local stkfmt = '\tif (!_marshallBin_adjustElmStk(pMarshaller,%su)) return%s;\n'
		-- output stack adjustment code to make sure the proper element type is being marshalled
		outbuf:append(stkfmt:format(sdbm_hash(parent.name), next(node.dependents) and ' retFuncs' or ''))
		-- output attributes
		outbuf:append('\t_buffer_append(pMarshaller, &tmpBuf, &pObj->m_id, sizeof(pObj->m_id));\n')
		table.map(node.attributes, function(k,v)
			outbuf:append(table.concat({
				'\t',c_type_info[v.type].binding.marshall.statement('&tmpBuf', c_type_info[v.type].buildVar('pObj->',k))
			}))
		end)
		-- output content
		if next(node.content) then
			local contentType = c_type_info[node.content.type]
			outbuf:append(table.concat({
				'\t',contentType.binding.marshall.statement('&tmpBuf', contentType.buildVar('pObj->',"Content"))
			}))
		end
		-- output function end code
		outbuf:append(table.concat({
			'\ttlv.m_size += tmpBuf.m_used;\n',
			'\t_buffer_append(pMarshaller, pOutBuf, &tlv, sizeof(xmlb_TLV));\n',
			'\t_buffer_append(pMarshaller, pOutBuf, tmpBuf.m_pBuf, tmpBuf.m_used);\n',
			'\t_buffer_destroy(pMarshaller, &tmpBuf);\n',
		}))
		-- output extra function end code if element has dependents
		if next(node.dependents) then
			outbuf:append(table.concat({
				'\t_buffer_pushElm(pMarshaller, &pMarshaller->m_elmStk, elemRec);\n',
				'\treturn retFuncs;\n'
			}))
		end
		outbuf:append('}\n')
	end)
	return outbuf:str()
][@lua -- output fist part of marshallBin function
	if next(schema.types[schema.root].dependents) then
		local depFncLst = table.filter(schema.types[schema.root].dependents, function(k,v)
			return table.concat({
				'.marshall_', k, ' = ', '_marshallBin_', k
			})
		end)
		depFncLst =  table.concat(depFncLst,', ')

		return table.concat({
			'marshall_', schema.root,' marshallBin(xmlb_marshaller* pMarshaller) {\n',
			'\tstatic const xmlb_elmRec  elemRec = {', sdbm_hash(schema.root), 'u, 0};\n',
			'\tmarshall_', schema.root, '  retFuncs= {', depFncLst, '};\n',
		})
	else
		return table.concat({
			'void marshallBin(xmlb_marshaller* pMarshaller) {\n',
			'\tstatic const xmlb_elmRec  elemRec = {', sdbm_hash(schema.root), 'u, 0};\n',
		})
	end
]	_buffer_destroy(pMarshaller, &pMarshaller->m_elmStk);
	_buffer_destroy(pMarshaller, &pMarshaller->m_mrshllBuf);
	_buffer_pushElm(pMarshaller, &pMarshaller->m_elmStk, elemRec);
[@lua if next(schema.types[schema.root].dependents) then return "\treturn retFuncs;\n" end]
}

xmlb_buffer marshallBin_flush(xmlb_marshaller* pMarshaller, int isDocEnd) {
	static const xmlb_buffer newBuf = { NULL, 0 };
	if (isDocEnd)
		_buffer_destroy(pMarshaller, &pMarshaller->m_elmStk);
	xmlb_buffer retBuf = pMarshaller->m_mrshllBuf;
	pMarshaller->m_mrshllBuf = newBuf;
	return retBuf;
}

[@lua --output unmarshalling functions
	local outbuf = stringBuffer:new()
	table.map(depOrderSansRoot, function(k, node)
		-- output function header
		local fncHdrFmt = 'static void _unmarshallBin_%s(xmlb_marshaller* pMarshaller, const uint8_t* pData, uint32_t parent) {\n'
		outbuf:append(fncHdrFmt:format(node.name))
		-- output standard inital code
		outbuf:append(table.concat({
			'\txmlb_',node.name,' elm;\n',
			'\tmemset(&elm, 0, sizeof(xmlb_',node.name,'));\n',
			'\telm.m_id = _streamRead(pData, uint32_t);\n'
		}))
		-- output code for each attribute
		table.map(node.attributes, function(k,v)
			outbuf:append(table.concat({
				'\t', c_type_info[v.type].binding.unmarshall.statement('pData', c_type_info[v.type].buildVar('elm.', k))
			}))
		end)
		-- output code for content
		if next(node.content) then
			local contentType = c_type_info[node.content.type]
			outbuf:append(table.concat({
				'\t', contentType.binding.unmarshall.statement('pData', contentType.buildVar('elm.', "Content"))
			}))
		end
		-- output standard end code
		outbuf:append(table.concat({'\tpMarshaller->unmarshall_',node.name,'(pMarshaller, &elm, parent);\n'}))
		-- output clean up code
		table.map(node.attributes, function(k,v)
			local contentType = c_type_info[v.type]
			outbuf:append(table.concat({
				'\t', contentType.delete.statement(contentType.buildVar('elm.', k))
			}))
		end)
		if next(node.content) then
			local contentType = c_type_info[node.content.type]
			outbuf:append(table.concat({
				'\t', contentType.delete.statement(contentType.buildVar('elm.', "Content"))
			}))
		end
		-- output end bracket
		outbuf:append('}\n')
	end)
	return outbuf:str()
]
void unmarshallBin(xmlb_marshaller* pMarshaller, const xmlb_buffer* pBuf) {
	xmlb_buffer* pRemBuf = &pMarshaller->m_remBuf;
	if (0 != pRemBuf->m_size) {
		xmlb_buffer tmpBuf;
		_buffer_append(pMarshaller, &tmpBuf, pRemBuf->m_pBuf, pRemBuf->m_used);
		_buffer_append(pMarshaller, &tmpBuf, pBuf->m_pBuf, pBuf->m_used);
		_buffer_destroy(pMarshaller, pRemBuf);
		unmarshallBin(pMarshaller, &tmpBuf);
		_buffer_destroy(pMarshaller, &tmpBuf);
	} else {
		const uint8_t* pBufLoc = pBuf->m_pBuf;
		uint8_t* const pBufEnd = pBuf->m_pBuf + pBuf->m_used;
		do {
			const uint32_t totalSz = pBuf->m_used - (pBufLoc - pBuf->m_pBuf);
			const xmlb_TLV* pTlv = (const xmlb_TLV*)pBufLoc;
			if ((totalSz < 12) || pTlv->m_size > totalSz) {
				_buffer_destroy(pMarshaller, pRemBuf);
				_buffer_append(pMarshaller, pRemBuf, pBufLoc, totalSz);
				pBufLoc += totalSz;
			} else {
				switch(pTlv->m_type) {
[@lua
	local outbuf = stringBuffer:new()
	table.map(depOrderSansRoot, function(k, v)
		outbuf:append(table.concat({
			'\t\t\t\tcase ',sdbm_hash(v.name),'u:\n',
			'\t\t\t\t\t_unmarshallBin_',v.name,'(pMarshaller, pTlv->m_data, pTlv->m_parent);\n',
			'\t\t\t\t\tbreak;\n',
		}))
	end)
	return outbuf:str()
]
				}
				pBufLoc += pTlv->m_size;
			}
		} while(pBufLoc < pBufEnd);
	}
}
