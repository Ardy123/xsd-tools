[@lua --include and transform old format
	include 'shared/trnsfrm_old'
	schema = trnsfrm_oldFmt(schema)
][@lua --include any shared 'helper' templates
	return include 'shared/schemaEx'
][@lua --include xsd to c type mapping
	return include 'c-xml-expat-sax/c_type_info'
][@lua --rename any non-c-safe names to c-safe names & sort dependencies so that they are matched correctly
	schema = schema.c_safeNames()
	depOrder = schema.sortDependencies()
	depOrderSansRoot = table.filter(depOrder, function(k,v) return v.name ~= schema.root and v or nil end)
][@lua -- find all unique types used in xsd
	uniqueXSDTypes = schema.uniqueTypes()
	-- map xsd types to unique c-types
	uniqueCTypes = {}
	table.map(uniqueXSDTypes, function(_, v)
		dbgPrint(v)
		local ctype = c_type_info[v]
		uniqueCTypes[ctype] = ctype
		if 'c_list' == ctype.type then
			local baseType = ctype.baseType()
			uniqueCTypes[baseType] = baseType
		end
	end)
	-- seperate list types from non-list types
	uniqueLists = table.filter(uniqueCTypes, function(_,v)
		if 'c_list' == v.type then return v end 
	end)
	uniqueNonLists = table.filter(uniqueCTypes, function(_,v)
		if 'c_list' ~= v.type then return v end 
	end)
][@lua -- create friendly root schema name
	schemaName = schema.types[schema.root].name:gsub("_xsd$", "")
]/* command to split output: csplit - '/\/\* FILE: /' {*} */
/* FILE: xml_common.h */
/* This file was generated by xsdb */
#include <stdint.h>

typedef struct {
	uint8_t*	m_pBuf;
	uint32_t	m_size;
	uint32_t	m_used;
} xml_buffer;

/* FILE: xml_[@lua return schemaName].h */
/* This file was generated by xsdb */
#include <string.h>
#include <expat.h>
#include "xml_common.h"

[@lua -- output all non-list type declarations
	local outbuf = stringBuffer:new()
	-- output basic type definitions
	table.map(uniqueNonLists, function(k,v)
		outbuf:append(v.c_type.definition())
		outbuf:append("\n")
	end)
	-- output list type definitions
	table.map(uniqueLists, function(k,v)
		outbuf:append(v.c_type.definition())
		outbuf:append("\n")
	end)
	-- output element definitions
	table.map(depOrderSansRoot, function(k, node)
		outbuf:append(table.concat({
			'typedef struct {\n',
			'\tuint32_t\t_eid;\n',
		}))
		table.map(node.attributes, function(name, xsdType) 
			outbuf:append(table.concat({
				'\t', c_type_info[xsdType.type].c_type.statement(name),
			}))
		end)
		if next(node.content) then
			outbuf:append(table.concat({
				'\t', c_type_info[node.content.type].c_type.statement("Content"),
			}))
		end
		outbuf:append('} xml_'..node.name..';\n\n')
	end)
	return outbuf:str()
]
typedef struct xml_marshaller {
	xml_buffer m_prsElmStk;
	xml_buffer m_mrshllElmStk;
	xml_buffer m_mrshllBuf;
	XML_Parser m_pParser;
	void* (*realloc)(struct xml_marshaller* pThis, void* pMem, size_t size);
[@lua --output unmarshalling callback structs
	local outbuf = stringBuffer:new()
	local methodFmtStr = '\tvoid (*unmarshal_%s)(struct xml_marshaller* pThis, const xml_%s* pObj, uint32_t parent);\n'
	table.map(depOrderSansRoot, function(k,v) outbuf:append(methodFmtStr:format(v.name, v.name)) end)
	return outbuf:str()
]} xml_marshaller;

[@lua --output marshalling callback structs
	local outbuf = stringBuffer:new()
	-- function for finding leaf nodes
	local isNotLeaf = (function(k,v) return next(v.dependents) and v or nil end)
	local isLeaf    = (function(k, v) return (not next(v.dependents)) and v or nil end)
	-- output code for all non-leaf functions
	table.map(table.filter(depOrder, isNotLeaf), function(k, node)
		outbuf:append('typedef struct {\n')
		-- find all child leaf nodes and output them
		table.map(table.filter(node.dependents, isLeaf), function(_, node)
			outbuf:append(string.format(
				'\tvoid (*marshal_%s)(xml_marshaller* pMarshaller, const xml_%s* pObj);\n',
				node.name,
				node.name
			))
		end)
		-- find all child  non leaf nodes and output them
		table.map(table.filter(node.dependents, isNotLeaf), function(_, node)
			outbuf:append(string.format(
				'\tmarshal_%s (*marshal_%s)(xml_marshaller* pMarshaller, const xml_%s* pObj);\n',
				node.name,
				node.name,
				node.name
			))
		end)
		outbuf:append('} marshal_'..node.name..';\n\n')
	end)
	return outbuf:str()
][@lua
	if next(schema.types[schema.root].dependents) then
		return table.concat({
			'marshal_', schema.root,' marshal(xml_marshaller* pMarshaller);\n',
		})
	else
		return 'void marshal(xml_marshaller* pMarshaller);\n'
	end
]xml_buffer marshal_flush(xml_marshaller* pMarshaller, int isDocEnd);
void unmarshal(xml_marshaller* pMarshaller, const xml_buffer* pBuf, int isDocEnd);

/* FILE: xml_[@lua return schemaName].c */
/* This file was generated by xsdb */
#include <stdio.h>
#include <stdlib.h>
#include <alloca.h>
#include "xml_[@lua return schemaName].h"
[@lua -- output libb64 headers if needed
	if uniqueCTypes[ctype_base64] then 
		return table.concat({
			'#include "b64/cencode.h"\n',
			'#include "b64/cdecode.h"\n',
		})
	end
]
#define _prsElmStack_index(BUF, NDX)		((xml_prsElmRec*)((BUF)->m_pBuf + ((BUF)->m_used + ((int)sizeof(xml_prsElmRec) * NDX))))
#define _prsElmStack_top(BUF)				_prsElmStack_size(BUF) ? (_prsElmStack_index(BUF, -1)) : NULL
#define _prsElmStack_push(PTR, BUF, VAL)	_buffer_append(PTR, BUF, &VAL, sizeof(xml_prsElmRec))
#define _prsElmStack_size(BUF)				((BUF)->m_used / sizeof(xml_prsElmRec))
#define _mrshllElmStack_index(BUF, NDX)		((xml_mrshllElmRec*)((BUF)->m_pBuf + ((BUF)->m_used + ((int)sizeof(xml_mrshllElmRec) * NDX))))
#define _mrshllElmStack_push(PTR, BUF, VAL)	_buffer_append(PTR, BUF, &VAL, sizeof(xml_mrshllElmRec))
#define _mrshllElmStack_top(BUF)			_mrshllElmStack_size(BUF) ? (_mrshllElmStack_index(BUF, -1)) : NULL
#define _mrshllElmStack_size(BUF)			((BUF)->m_used / sizeof(xml_mrshllElmRec))
#define _safeCStr(STR)						((STR) ? (STR) : "")
#define _CStrCpy(ALLOCATOR, STR)			strcpy((ALLOCATOR)->realloc((ALLOCATOR), NULL, strlen((STR)) + 1), (STR))

typedef xml_buffer xml_cstr;

typedef union {
[@lua -- output element type union
	local outbuf = stringBuffer:new()
	local frmtStr = "\txml_%s\tm_%s;\n"
	table.map(depOrderSansRoot, function(_,v)
		outbuf:append(string.format(
			"\txml_%s\tm_%s;\n",
			v.name,
			v.name)
		)
	end)
	return outbuf:str()
]} xml_typeUnion;

typedef struct {
	uint32_t m_typeId;
	xml_cstr m_contentAccum;
	xml_typeUnion m_element;
} xml_prsElmRec;

typedef struct {
	uint32_t	m_type, m_id;
} xml_mrshllElmRec;

static __thread uint32_t gtlssIdCnt = 1;
static __thread xml_marshaller* gtlsspMarshler = NULL;

static xml_prsElmRec* _prsElmStack_pop(xml_buffer* pBuf) {
	xml_prsElmRec* pRet = _prsElmStack_top(pBuf);
	pBuf->m_used -= (_prsElmStack_size(pBuf) ? sizeof(xml_prsElmRec) : 0);
	return pRet;
}

static xml_mrshllElmRec* _mrshllElmStack_pop(xml_buffer* pBuf) {
	xml_mrshllElmRec* pRet = _mrshllElmStack_top(pBuf);
	pBuf->m_used -= (_mrshllElmStack_size(pBuf) ? sizeof(xml_mrshllElmRec) : 0);
	return pRet;
}

static uint32_t _SDBMHash(uint32_t hash, const char* pName) {
	for (; *pName; ++pName)
		hash = *pName + (hash << 6) + (hash << 16) - hash;
	return hash;
}

static void _buffer_init(xml_marshaller* pMarshaller, xml_buffer* pBuf) {
	pBuf->m_pBuf = pMarshaller->realloc(pMarshaller, pBuf->m_pBuf, 256);
	pBuf->m_size = 256;
	pBuf->m_used = 0;
}

static void _buffer_destroy(xml_marshaller* pMarshaller, xml_buffer* pBuf) {
	pBuf->m_pBuf = pMarshaller->realloc(pMarshaller, pBuf->m_pBuf, 0);
	memset(pBuf, 0, sizeof(xml_buffer));
}

static void _buffer_append(xml_marshaller* pMarshaller, xml_buffer* pBuf, const void* pBlk, uint32_t size) {
	const uint32_t totalSz = size + pBuf->m_used;
	if (totalSz >= pBuf->m_size) {
		pBuf->m_pBuf = pMarshaller->realloc(pMarshaller, pBuf->m_pBuf, (pBuf->m_size) ? pBuf->m_size <<= 1 : (pBuf->m_size = 256));
	}
	memcpy(pBuf->m_pBuf + pBuf->m_used, pBlk, size);
	pBuf->m_used += size;
}

__attribute__((unused))
static void _cstr_init(xml_marshaller* pMarshaller, xml_cstr* pCStr) {
	_buffer_init(pMarshaller, pCStr);
	_buffer_append(pMarshaller, pCStr, "", 1);
}

static void _cstr_destroy(xml_marshaller* pMarshaller, xml_cstr* pCStr) {
	_buffer_destroy(pMarshaller, pCStr);
}

static void _cstr_append(xml_marshaller* pMarshaller, xml_cstr* pCStr, const char* pStr) {
	pCStr->m_used -= 1;
	_buffer_append(pMarshaller, pCStr, pStr, strlen(pStr) + 1);
}

__attribute__((unused))
static char* _cstr_cstr(xml_cstr* pCStr) {
	return (char*)pCStr->m_pBuf;
}

static int _marshal_adjustElmStk(xml_marshaller* pMarshaller, uint32_t validType) {
	const xml_mrshllElmRec* pElm;
	xml_cstr* pOutStr = &pMarshaller->m_mrshllBuf;
	xml_buffer* pElmStk = &pMarshaller->m_mrshllElmStk;
	for (pElm = _mrshllElmStack_top(pElmStk); pElm && (pElm->m_type != validType); pElm = _mrshllElmStack_top(pElmStk)) {
		switch(pElm->m_type) {
[@lua -- output close tag handler for each element type
	local outbuf = stringBuffer:new()
	table.map(depOrderSansRoot, function(_,node)
		outbuf:append(table.concat({
			"\t\tcase ", sdbm_hash(node.name), ":\n",
			"\t\t\t_cstr_append(pMarshaller, pOutStr, \"</", node.name, ">\");\n",
			"\t\t\tbreak;\n",
		}))
	end)
	return outbuf:str()
]		default: break;
		}
		_mrshllElmStack_pop(pElmStk);
	}
	/* work around potentially unused argument warnings */
	(void)pOutStr;
	return (pElm) ? 1 : 0;
}

[@lua --output basic type marshalling functions
	local outbuf = stringBuffer:new()
	table.map(uniqueNonLists, function(_, xsdtype)
		outbuf:append(xsdtype.binding.marshal.definition())
		outbuf:append("\n")
	end)
	return outbuf:str()
]

[@lua -- output list marshalling functions
	local outbuf = stringBuffer:new()
	table.map(uniqueLists, function(_, xsdtype)		
		outbuf:append(xsdtype.binding.marshal.definition())
		outbuf:append("\n")
	end)
	return outbuf:str()
]

[@lua --output marshalling functions
	local outbuf = stringBuffer:new()
	table.map(depOrderSansRoot, function(k, node)
		-- output function header
		local fncHdrFmt = 'static %s _marshal_%s(xml_marshaller* pMarshaller, const xml_%s* pObj) {\n'
		outbuf:append(fncHdrFmt:format(
			(not next(node.dependents)) and 'void' or 'marshal_'..node.name,
			node.name,
			node.name
		))
		-- output some variable declerations
		outbuf:append(table.concat({
			'\txml_cstr* pOutStr = &pMarshaller->m_mrshllBuf;\n',
			'\tconst xml_mrshllElmRec elemRec = {',sdbm_hash(node.name),'u, pObj->_eid};\n',
		}))
		-- output return struct if element had dependents
		if next(node.dependents) then
			local depFncLst = table.filter(node.dependents, function(k,v) 
				return table.concat({
					'.marshal_', k, ' = ', '_marshal_', k
				})
			end)
			outbuf:append(table.concat({
				'\tstatic const marshal_',node.name,' retFuncs = {',table.concat(depFncLst,', '),'};\n',
			}))
		end
		-- find parent node of this node
		local function findParent(root, key)
			local _, dep = next(root.dependents, key)
			if not dep or dep == node then
				return dep == node and root or dep
			else
				return findParent(dep) or findParent(root, dep.name)
			end
		end
		local parent = findParent(schema.types[schema.root])
		-- output stack adjustment code to make sure the proper element type is being marshalled
		local stkfmt = '\tif (!_marshal_adjustElmStk(pMarshaller, %su)) return%s;\n'
		outbuf:append(stkfmt:format(sdbm_hash(parent.name), next(node.dependents) and ' retFuncs' or ''))
		-- output start tag
		outbuf:append(table.concat({
			'\t_cstr_append(pMarshaller, pOutStr, "<', node.name, '");\n'
		}))
		-- output attributes
		table.map(node.attributes, function(k,v)
			local attribType = c_type_info[v.type]
			outbuf:append(table.concat({
				'\t_cstr_append(pMarshaller, pOutStr, "', k, '=\\"");\n',
				'\t', attribType.binding.marshal.statement('pOutStr', attribType.buildVar('pObj->',k)),
			}))
		end)
		-- output end of start tag
		outbuf:append('\t_cstr_append(pMarshaller, pOutStr, ">");\n')
		-- output content
		if next(node.content) then
			local contentType = c_type_info[node.content.type]
			outbuf:append(table.concat({
				'\t', contentType.binding.marshal.statement('pOutStr', contentType.buildVar('pObj->','Content'))
			}))
		end
		-- output function end code
		outbuf:append('\t_mrshllElmStack_push(pMarshaller, &pMarshaller->m_mrshllElmStk, elemRec);\n')
		-- output extra function end code if element has dependents
		if next(node.dependents) then
			outbuf:append('\treturn retFuncs;\n')
		end
		outbuf:append('}\n')
	end)
	return outbuf:str()
]
[@lua -- output fist part of marshal function
	if next(schema.types[schema.root].dependents) then
		local depFncLst = table.filter(schema.types[schema.root].dependents, function(k,v) 
			return table.concat({
				'.marshal_', k, ' = ', '_marshal_', k
			})
		end)
		depFncLst =  table.concat(depFncLst,', ')
		return table.concat({
			'marshal_', schema.root,' marshal(xml_marshaller* pMarshaller) {\n',
			'\tconst xml_mrshllElmRec elemRec = {', sdbm_hash(schema.root), 'u, 0};\n',
			'\tmarshal_', schema.root, '  retFuncs= {', depFncLst, '};\n',
		})
	else
		return table.concat({
			'void marshal(xml_marshaller* pMarshaller) {\n',
			'\tconst xml_mrshllElmRec elemRec = {', sdbm_hash(schema.root), 'u, 0};\n',
		})
	end
]	xml_cstr* pOutStr = &pMarshaller->m_mrshllBuf;
	_buffer_init(pMarshaller, &pMarshaller->m_mrshllElmStk);
	_cstr_init(pMarshaller, &pMarshaller->m_mrshllBuf);
	_mrshllElmStack_push(pMarshaller, &pMarshaller->m_mrshllElmStk, elemRec);
	_cstr_append(pMarshaller, pOutStr, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
[@lua if next(schema.types[schema.root].dependents) then return "\treturn retFuncs;" end]
}

xml_buffer marshal_flush(xml_marshaller* pMarshaller, int isDocEnd) {
	static const xml_buffer newBuf = { NULL, 0, 0 };
	xml_buffer retBuf = pMarshaller->m_mrshllBuf;
	if (isDocEnd) {
		_marshal_adjustElmStk(pMarshaller,0);
		_buffer_destroy(pMarshaller, &pMarshaller->m_mrshllElmStk);
		retBuf = pMarshaller->m_mrshllBuf;
		pMarshaller->m_mrshllBuf = newBuf;
	} else {
		pMarshaller->m_mrshllBuf = newBuf;
		_buffer_init(pMarshaller, &pMarshaller->m_mrshllBuf);
	}
	return retBuf;
}

static void* _expatMalloc(size_t size) {
	return gtlsspMarshler->realloc(gtlsspMarshler, NULL, size);
}

static void* _expatRealloc(void *ptr, size_t size) {
	return gtlsspMarshler->realloc(gtlsspMarshler, ptr, size);
}

static void _expatFree(void *ptr) {
	if (ptr) gtlsspMarshler->realloc(gtlsspMarshler, ptr, 0);
}

[@lua -- output baseic type unmarshalling & deletion functions
	local outbuf = stringBuffer:new()
	table.map(uniqueNonLists, function(_, xsdtype)
		outbuf:append(xsdtype.binding.unmarshal.definition())
		outbuf:append("\n")
		outbuf:append(xsdtype.delete.definition())
		outbuf:append("\n")
	end)
	return outbuf:str()
]

[@lua -- output list unmarshalling functions
	local outbuf = stringBuffer:new()
	table.map(uniqueLists, function(_, xsdtype)
		outbuf:append(xsdtype.binding.unmarshal.definition())
		outbuf:append("\n")
		outbuf:append(xsdtype.delete.definition())
		outbuf:append("\n")
	end)
	return outbuf:str()
]
static void _prsElmRec_init(xml_prsElmRec* pElmRec, xml_marshaller* pMarshaller, const char* pElmName, const char** ppAttrs) {
	char strBuf[16];
	memset(pElmRec, 0, sizeof(xml_prsElmRec));
	snprintf(strBuf, sizeof(strBuf) - 1, "%d", gtlssIdCnt++);
	pElmRec->m_typeId = _SDBMHash(0, pElmName);
	_cstr_init(pMarshaller, &pElmRec->m_contentAccum);
	switch(pElmRec->m_typeId) {
[@lua --output element construction code
	local outbuf = stringBuffer:new()
	table.map(depOrderSansRoot, function(_, node)
		-- output std constructor
		outbuf:append(table.concat({
			'\tcase ', sdbm_hash(node.name), 'u:\n',
			'\t\tpElmRec->m_element.m_', node.name, '._eid = _SDBMHash(pElmRec->m_typeId, strBuf);\n',
		}))
		-- output default attribute construction
		local objName = 'pElmRec->m_element.m_'..node.name..'.'
		table.map(node.attributes, function(name, attrib)
			if attrib.default then
				local attribType = c_type_info[attrib.type]
				outbuf:append(table.concat({
					'\t\t\t', attribType.binding.unmarshal.statement('"'..attrib.default..'"', attribType.buildVar(objName,name)),
				}))
			end
		end)
		-- output attribute assignments
		if next(node.attributes) then
			outbuf:append(table.concat({
				'\t\tfor ( ; *ppAttrs ; ppAttrs+=2) {\n',
				'\t\t\tswitch(_SDBMHash(0, *ppAttrs)) {\n',
			}))
			table.map(node.attributes, function(name, attrib)
				local attribType = c_type_info[attrib.type]
				outbuf:append(table.concat({
					'\t\t\tcase ', sdbm_hash(name), 'u:\n',
					'\t\t\t\t', attribType.binding.unmarshal.statement('*(ppAttrs + 1)',attribType.buildVar(objName, name)),
					'\t\t\t\tbreak;\n',
				}))
				-- TODO
			end)
			outbuf:append(table.concat({
				'\t\t\tdefault:break;\n',
				'\t\t\t}\n',
				'\t\t}\n',
			}))
		end
		-- output case break for element type
		outbuf:append('\t\tbreak;\n')
	end)
	-- output default case and function end code
	outbuf:append(table.concat({
		'\tdefault: break;\n',
		'\t}\n',
		'\t\t(void)ppAttrs;\n',
		'}\n'
	}))
	return outbuf:str()
]
static void _prsElmRec_destory(xml_prsElmRec* pElmRec, xml_marshaller* pMarshaller) {
	if (pElmRec) {
		switch(pElmRec->m_typeId) {
[@lua -- output element record destructor function
	local outbuf = stringBuffer:new()
	table.map(depOrderSansRoot, function(_, node)
		-- output case statement for element
		outbuf:append(table.concat({'\t\tcase ', sdbm_hash(node.name), 'u:\n',}))
		-- output destructor for each attribute
		local objName = 'pElmRec->m_element.m_'..node.name..'.'
		table.map(node.attributes, function(name, attrib)
			local attribType = c_type_info[attrib.type]
			outbuf:append(table.concat({
				'\t', attribType.delete.statement(attribType.buildVar(objName, name))
			}))
		end)
		-- output destructor for content
		if next(node.content) then
			local contentType = c_type_info[node.content.type]
			outbuf:append(table.concat({
				'\t\t\t', contentType.delete.statement(contentType.buildVar(objName, "Content"))
			}))
		end
		outbuf:append('\t\t\tbreak;\n')
	end)
	return outbuf:str()
]		default: break;
		}
		_cstr_destroy(pMarshaller, &pElmRec->m_contentAccum);
	}
}

static uint32_t _prsElmRec_id(xml_prsElmRec* pElmRec) {
	if (pElmRec) {
		switch(pElmRec->m_typeId) {
[@lua -- output element id return
	local outbuf = stringBuffer:new()
	table.map(depOrderSansRoot, function(_, node)
		outbuf:append(table.concat({
			'\t\tcase ', sdbm_hash(node.name), ':\n',
			'\t\t\t return pElmRec->m_element.m_', node.name, '._eid;\n',
		}))
	end)
	return outbuf:str()
]		default: break;
		}
	}
	return 0;
}

static void _prsElmRec_invoke(xml_prsElmRec* pElmRec, xml_marshaller* pMarshaller, const uint32_t parentId) {
	if (pElmRec) {
		switch(pElmRec->m_typeId) {
[@lua -- output element content assignment and data notification invocation
	local outbuf = stringBuffer:new()
	table.map(depOrderSansRoot, function(_, node)
		outbuf:append(table.concat({'\t\tcase ', sdbm_hash(node.name), ':\n'}))
		if next(node.content) then
			local contentType = c_type_info[node.content.type]
			outbuf:append(table.concat({
				'\t\t\t', contentType.binding.unmarshal.statement('_cstr_cstr(&pElmRec->m_contentAccum)',contentType.buildVar('pElmRec->m_element.m_'..node.name..'.', 'Content')),
			}))
		end
		outbuf:append(table.concat({
			'\t\t\tpMarshaller->unmarshal_', node.name, '(pMarshaller, &pElmRec->m_element.m_', node.name, ', parentId);\n',
		}))
		outbuf:append('\t\tbreak;\n')
	end)
	return outbuf:str()
]		default: break;
		}
	}
	/* work around potentially unused arguments warnings */
	(void)pMarshaller;
	(void)parentId;
}

static void _prsElmRec_appendContent(xml_marshaller* pMarshaller, xml_prsElmRec* pElmRec, const char* pContent, int sz) {
	if (pElmRec) {
		pElmRec->m_contentAccum.m_used -= 1;
		_buffer_append(pMarshaller, &pElmRec->m_contentAccum, pContent, sz);
		_buffer_append(pMarshaller, &pElmRec->m_contentAccum, "", 1);
	}
}

static void _expatStartElementHandler(void* pCtx, 
									 const XML_Char* pName, 
									 const XML_Char** ppattrs) {
	const char* pElmName = strrchr(pName, ':') ? strrchr(pName, ':') + 1: pName;
	xml_marshaller* pMarshaller = (xml_marshaller*)pCtx;
	xml_prsElmRec elemRec;
	_prsElmRec_init(&elemRec, pMarshaller, pElmName, ppattrs);
	_prsElmStack_push(pMarshaller, &pMarshaller->m_prsElmStk, elemRec);
}

static void _expatEndElementHandler(void* pCtx, const XML_Char* pName) {
	xml_marshaller* pMarshal	= (xml_marshaller*)pCtx;
	xml_prsElmRec*	pBufTop		= _prsElmStack_pop(&pMarshal->m_prsElmStk);
	const uint32_t	parentId	= _prsElmRec_id(_prsElmStack_top(&pMarshal->m_prsElmStk));
	_prsElmRec_invoke(pBufTop, pMarshal, parentId);
	_prsElmRec_destory(pBufTop, pMarshal);
	(void)pName;
}

static void _expatCharacterDataHandler(void* pCtx, const XML_Char* pStr, int len) {
	xml_marshaller* pMarshal = (xml_marshaller*)pCtx;
	xml_prsElmRec* pBufTop = _prsElmStack_top(&pMarshal->m_prsElmStk);
	/* append it to current data */
	_prsElmRec_appendContent(pMarshal, pBufTop, pStr, len);
}

void unmarshal(xml_marshaller* pMarshaller, const xml_buffer* pBuf, int isDocEnd) {
	static const XML_Memory_Handling_Suite memSuite = {
		_expatMalloc,
		_expatRealloc,
		_expatFree,
	};
	gtlsspMarshler =  pMarshaller;
	/* initialize if needed */
	if (NULL == pMarshaller->m_pParser) {
		pMarshaller->m_pParser = XML_ParserCreate_MM("utf-8", &memSuite, ":");
		XML_SetUserData(pMarshaller->m_pParser, pMarshaller);
		XML_SetElementHandler(pMarshaller->m_pParser, _expatStartElementHandler, _expatEndElementHandler);
		XML_SetCharacterDataHandler(pMarshaller->m_pParser, _expatCharacterDataHandler);
		_buffer_init(pMarshaller, &pMarshaller->m_prsElmStk);
	}
	XML_Parse(pMarshaller->m_pParser, (const char *)pBuf->m_pBuf, pBuf->m_used, isDocEnd);
	/* clean up properly */
	if (isDocEnd) {
		XML_ParserFree(pMarshaller->m_pParser);
		pMarshaller->m_pParser = NULL;
		_buffer_destroy(pMarshaller, &pMarshaller->m_prsElmStk);
	}
}
