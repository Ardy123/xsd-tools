[@lua --define list type
	c_list = {}
	function c_list:new(base)
		local function calcName() 
			return table.concat({'xmlb_', base.c_type.name():gsub('[ *]', ''), 'List',})
		end
		return {
			type = 'c_list',
			c_type = {
				name = calcName(),
				definition = function() 
					return table.concat({
						'typedef struct {\n',
						'\t', base.c_type.name(), '\t*', base.buildVar('','pArray'), ';\n',
						'\tuint32_t\tm_nElements;\n',
						'} ', calcName(), ';\n',
					})
				end,
				statement = function(varName) 
					return table.concat({
						calcName(), '\tm_', varName, ';\n',
					})
				end,
			},
			delete = {
				definition = function() 
					local objArray = base.buildVar('pObj->','pArray')
					return table.concat({
						'static void _destroy_', calcName(), '(xmlb_marshaller* pMarshaller, ', calcName(), '* pObj) {\n',
						'\tif (', objArray, ') {\n',
						'\t\tint ndx;\n',
						'\t\tfor (ndx = 0; ndx < pObj->m_nElements; ++ndx) {\n',
						'\t\t\t', base.delete.statement(objArray..'[ndx]'),
						'\t\t}\n',
						'\t\tpMarshaller->realloc(pMarshaller, ', objArray, ', 0);\n',
						'\t\}\n',
						'}\n',
					})
				end,
				statement = function(obj) 
					return table.concat({
						'_destroy_', calcName(), '(pMarshaller, &', obj, ');\n',
					})
				end,
			},
			buildVar = function(obj, member) 
				return table.concat({obj,'m_',member})
			end,
			baseType = function()
				return base
			end,
			binding = {
				marshall = {
					definition = function() 
						return table.concat({
							'static void _marshallBin_', calcName(), '(xmlb_marshaller* pMarshaller, xmlb_buffer* pOutBuffer, const ', calcName(), '* pObj) {\n',
							'\tint ndx;\n',
							'\t_buffer_append(pMarshaller, pOutBuffer, &pObj->m_nElements, sizeof(pObj->m_nElements));\n',
							'\tfor (ndx = 0; ndx < pObj->m_nElements; ++ndx) {\n',
							'\t', base.binding.marshall.statement('pOutBuffer', base.buildVar('pObj->','pArray[ndx]')),
							'\t}\n',
							'}\n',
						})
					end,
					statement = function(dst, obj)
						return table.concat({
							'_marshallBin_', calcName(), '(pMarshaller, ', dst, ', &', obj, ');\n',
						})
					end,
				},
				unmarshall = {
					definition = function()
						local arrayVar = base.buildVar('pObj->','pArray')
						return table.concat({
							'static void _unmarshall_', calcName(), '(xmlb_marshaller* pMarshaller, const uint8_t* pData, ', calcName(), '* pObj) {\n',
							'\tint ndx;\n',
							'\tpObj->m_nElements = _streamRead(pData, uint32_t);\n',
							'\t',arrayVar,' = pMarshaller->realloc(pMarshaller, NULL, sizeof(',base.c_type.name(),') * pObj->m_nElements);\n',
							'\tfor (ndx = 0; ndx < pObj->m_nElements; ++ndx) {\n',
							'\t\t', base.binding.unmarshall.statement('pData', arrayVar..'[ndx]'),
							'\t}\n',
							'}\n',
						})
					end,
					statement = function(src, obj)
						return table.concat({
							'_unmarshall_', calcName(), '(pMarshaller, ', src, ', &', obj, ');\n'
						})
					end,
				},
			},
			test = {
				subDef = function(var)
					local value = { base.test.assign(), base.test.assign(), base.test.assign() }
					return table.concat({
						"static ", base.c_type.name(), " ", var, "[] = { ", table.concat(value, ", "), " };\n"
					})
				end,
				assign = function(subDefObj)
					return string.format(
						'{ %s = %s, .m_nElements = sizeof(%s)/sizeof(%s[0]) }', 
						base.buildVar('.','pArray'), 
						subDefObj, subDefObj, subDefObj
					)
				end,
				assert = function(obj1, obj2)
					return table.concat({
						string.format("\tassert(%s.m_nElements ==  %s.m_nElements);\n", obj1, obj2),
						"\t{\n",
						"\t\tint ndx;\n",
						string.format("\t\tfor(ndx = 0; ndx < %s.m_nElements; ++ndx) {\n", obj1),
						"\t\t", base.test.assert(obj1..base.buildVar('.','pArray')..'[ndx]', obj2..base.buildVar('.','pArray')..'[ndx]'),
						"\t\t}\n",
						"\t}\n",
					})
				end
			},
		}
	end
]